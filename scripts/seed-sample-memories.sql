-- Sample Data Seeding Script for Memory Visualizer Testing
-- This script creates sample memory entries for the current authenticated user
-- Run this in Supabase SQL Editor to populate test data

-- Note: Replace auth.uid() with your actual user UUID if running from external tool
-- Or run directly in Supabase SQL Editor while authenticated

-- Sample memory entries with various types
INSERT INTO public.memory_entries (user_id, content, type, tags, metadata)
VALUES 
  -- Project memories
  (
    auth.uid(), 
    'Initialized the LanOnasis Memory Service project with React, TypeScript, and Tailwind CSS. Set up the monorepo structure using Turborepo and configured Supabase for authentication and database.',
    'project',
    '["onboarding", "setup", "lanonasis", "supabase"]'::jsonb,
    '{"importance": "high", "project": "memory-service"}'::jsonb
  ),
  (
    auth.uid(),
    'Implemented the API key management system with proper RLS policies. Users can now create, view, and delete their own API keys securely. Added rate limiting and usage tracking.',
    'project',
    '["api", "security", "rls"]'::jsonb,
    '{"importance": "high", "project": "memory-service"}'::jsonb
  ),

  -- Knowledge memories
  (
    auth.uid(),
    'Vector embeddings in Supabase use the pgvector extension. Embeddings are 1536-dimensional arrays generated by OpenAI text-embedding-ada-002 model. Cosine similarity is used for semantic search with threshold typically set to 0.7 or higher.',
    'knowledge',
    '["vectors", "embeddings", "pgvector", "openai"]'::jsonb,
    '{"source": "supabase-docs", "confidence": "high"}'::jsonb
  ),
  (
    auth.uid(),
    'Row-Level Security (RLS) in Postgres allows fine-grained access control at the row level. Policies can be defined for SELECT, INSERT, UPDATE, and DELETE operations. Essential for multi-tenant applications where data isolation is critical.',
    'knowledge',
    '["security", "postgres", "rls", "database"]'::jsonb,
    '{"source": "postgres-docs", "confidence": "high"}'::jsonb
  ),

  -- Context memories
  (
    auth.uid(),
    'Working on the Memory Visualizer feature. Need to display the last 20 memories with type badges, tags, and relative timestamps. The UI should match the existing dark theme and be responsive.',
    'context',
    '["ui", "frontend", "memory-visualizer"]'::jsonb,
    '{"status": "in-progress", "priority": "high"}'::jsonb
  ),
  (
    auth.uid(),
    'Current focus: Implementing AI Workflow Orchestrator that uses GPT-4o-mini to generate multi-step workflow plans. Need to integrate with user memories as context and store results in workflow_runs table.',
    'context',
    '["ai", "orchestrator", "openai", "workflow"]'::jsonb,
    '{"status": "planning", "priority": "high"}'::jsonb
  ),

  -- Reference memories
  (
    auth.uid(),
    'Supabase Edge Functions use Deno runtime. Support for TypeScript out of the box. Can be invoked via REST API or directly from client SDK. Ideal for server-side logic, webhooks, and background jobs.',
    'reference',
    '["supabase", "edge-functions", "deno", "serverless"]'::jsonb,
    '{"url": "https://supabase.com/docs/guides/functions"}'::jsonb
  ),
  (
    auth.uid(),
    'OpenAI API rate limits: Free tier allows 3 requests per minute. GPT-4o-mini costs $0.15 per 1M input tokens and $0.60 per 1M output tokens. Good for development and testing before scaling.',
    'reference',
    '["openai", "pricing", "rate-limits"]'::jsonb,
    '{"url": "https://openai.com/pricing"}'::jsonb
  ),

  -- Workflow memories
  (
    auth.uid(),
    'Standard workflow for adding new features: 1) Design database schema, 2) Create migration files, 3) Update Drizzle schema, 4) Implement API endpoints, 5) Build frontend components, 6) Add tests, 7) Document in README.',
    'workflow',
    '["process", "development", "best-practices"]'::jsonb,
    '{"team": "engineering", "category": "development"}'::jsonb
  ),

  -- Personal memories
  (
    auth.uid(),
    'Prefer using Bun over npm for faster package installation and better TypeScript support. Remember to use bun run instead of npm run for scripts.',
    'personal',
    '["preferences", "tooling", "bun"]'::jsonb,
    '{"category": "preferences"}'::jsonb
  ),

  -- Note memories
  (
    auth.uid(),
    'TODO: Add semantic search functionality to Memory Visualizer. Need to implement vector similarity search using pgvector extension and OpenAI embeddings.',
    'note',
    '["todo", "enhancement", "search"]'::jsonb,
    '{"priority": "medium", "estimated_hours": 8}'::jsonb
  ),
  (
    auth.uid(),
    'Bug found: Memory cards not displaying properly on mobile devices below 640px width. Need to adjust responsive breakpoints in Tailwind CSS.',
    'note',
    '["bug", "responsive", "mobile", "ui"]'::jsonb,
    '{"priority": "low", "browser": "chrome-mobile"}'::jsonb
  ),

  -- Document memories
  (
    auth.uid(),
    'Architecture Decision Record (ADR): Decided to use Drizzle ORM instead of Prisma for better PostgreSQL support and TypeScript inference. Drizzle provides more control over queries and better performance for our use case.',
    'document',
    '["adr", "architecture", "decisions"]'::jsonb,
    '{"decision_id": "ADR-001", "status": "accepted"}'::jsonb
  ),

  -- Additional varied examples
  (
    auth.uid(),
    'Learned that Next.js 14 App Router uses React Server Components by default. This reduces client-side JavaScript and improves performance. Need to mark client components with "use client" directive.',
    'knowledge',
    '["nextjs", "react", "performance"]'::jsonb,
    '{"framework_version": "14.0"}'::jsonb
  ),
  (
    auth.uid(),
    'Meeting notes: Discussed roadmap for Q4. Priority features include: 1) Semantic search, 2) Workflow templates, 3) Mobile app, 4) Team collaboration features. Target launch: December 2025.',
    'note',
    '["meetings", "planning", "roadmap"]'::jsonb,
    '{"meeting_date": "2025-11-01", "attendees": 5}'::jsonb
  );

-- Verify the data was inserted
SELECT 
  id,
  LEFT(content, 50) as content_preview,
  type,
  array_length(tags::text[]::text[], 1) as tag_count,
  created_at
FROM public.memory_entries
WHERE user_id = auth.uid()
ORDER BY created_at DESC;

-- Check total count
SELECT 
  type,
  COUNT(*) as count
FROM public.memory_entries
WHERE user_id = auth.uid()
GROUP BY type
ORDER BY count DESC;

